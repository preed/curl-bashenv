#!/bin/bash

#set -v

set -e
set -o pipefail
#set -x

# Programs we use

BASENAME="${BASENAME:-basename}"
CAT="${CAT:-cat}"
CP="${CP:-cp}"
CURL="${CURL:-curl}"
GIT="${GIT:-git}"
GREP="${GREP:-grep}"
LS="${LS:-ls}"
LN="${LN:-ln}"
MKDIR="${MKDIR:-mkdir}"
MV="${MV:-mv}"
SCP="${SCP:-scp}"
SED="${SED:-sed}"
SSH="${SSH:-ssh}"
SSH_KEYGEN="${SSH_KEYGEN:-ssh-keygen}"
TR="${TR:-tr}"

# Config vars
BACKUP_DIR="${BACKUP_DIR:-$HOME/.curl-bashenv-backup}"
BACKUP_SETUP_DIR="${BACKUP_SETUP_DIR:-${BACKUP_DIR}/.setup}"

SETUP_STEPS="${SETUP_STEPS:-ssh shdotfiles gitconfig}"
SHDOTFILES="${SHDOTFILES:-bashrc bash_profile}"

# TODO: Add platform test for Mac
SSH_KEYGEN_ARGS="${SSH_KEYGEN_ARGS:- -t ed25519 -o -a 100}"

SOURCE=${SOURCE:-""}
SOURCE_GIT_CLONE_DIR="${SOURCE_GIT_CLONE_DIR:-${BACKUP_SETUP_DIR}/gitclone}"
GIT_CLONE_ARGS="${GIT_CLONE_ARGS:-}"
DOTFILE_PREFIX="${DOTFILE_PREFIX:-.}"

# BASE_URL="define other steps"

# source: copy source key here
# create: create a local key
# createauthorize: create a local key and copy it to the source

SSH_KEY_MODE=${SSH_KEY_MODE:-create}
SSH_KEY_NAME=${SSH_KEY_NAME:-~/.ssh/id_dsa}
SSH_PUB_KEY_NAME=${SSH_PUB_KEY_NAME:-${SSH_KEY_NAME}.pub}

# Nabbed from: http://stackoverflow.com/questions/1527049/bash-join-elements-of-an-array
function join { local IFS="$1"; shift; echo "$*"; }

function assert() {
	echo "$1" > /dev/stderr
	exit -1
}

function error_out() {
	echo "$1" > /dev/stderr
	test -n "$2" && exit $2
	exit 1
}

function symlink_gitrepo_file() {
	test -z "$1" && assert "symlink_gitrepo_file: first arg empty"
	repo_file="${DOTFILE_PREFIX}$1"
	source_file="${SOURCE_GIT_CLONE_DIR}/$repo_file"

	test -e $HOME/$1 && $MV $HOME/$1 ${BACKUP_DIR}
	$LN -s "$source_file" $HOME/$1
}


function setup_ssh() {
	local sshBackupDir="${BACKUP_DIR}/.ssh"

	keyMode=$(echo $SSH_KEY_MODE | $TR "[:upper:]" "[:lower:]")
	if [ "$keyMode" != "create" ] &&
	   [ "$keyMode" != "source" ] &&
	   [ "$keyMode" != "createauthorize" ]; then
		error_out "Invalid SSH_KEY_MODE '$SSH_KEY_MODE'; must be source, create, or createauthorize"
	fi

	local sourceHostname="$(echo $SOURCE | $SED -e 's:\(.*\)@\(.*\):\2:')"
	if test -z "$($GREP "^$sourceHostname" $HOME/.ssh/known_hosts)"; then
		$SSH $SOURCE "bash -c 'for f in /etc/ssh/ssh_host_*_key.pub; do test -f \$f && $SSH_KEYGEN -l -f \$f; done'"
		echo "Validate one of the keys displayed above matches the key you accepted; if not, you were just MITM'd! Use ctrl-c to stop $0"
		read
	fi

	if test -n "$(echo $keyMode | $GREP create)"; then
		test -e $SSH_KEY_NAME || $SSH_KEYGEN $SSH_KEYGEN_ARGS -f $SSH_KEY_NAME
	elif [ "$keyMode" == "source" ]; then
		test -e $SSH_KEY_NAME || $MV $SSH_KEY_NAME $sshBackupDir
		test -e $SSH_PUB_KEY_NAME || $MV $SSH_PUB_KEY_NAME $sshBackupDir
		$SCP $SOURCE:~/.ssh/\{$SSH_KEY_NAME,$SSH_PUB_KEY_NAME\} $BACKUP_SETUP_DIR
		$MV $BACKUP_SETUP_DIR/$($BASENAME $SSH_KEY_NAME) $HOME/.ssh
		$MV $BACKUP_SETUP_DIR/$($BASENAME $SSH_PUB_KEY_NAME) $HOME/.ssh
	else
		assert "setup_ssh(): UNREACHABLE."
	fi

	if [ "$keyMode" == "createauthorize" ]; then
		if ! test -e ${SSH_PUB_KEY_NAME}; then
			error_out "Couldn't find $SSH_PUB_KEY_NAME; bailing"
		fi
		# Yes, I know ssh-copy-id exists; we do this because for some
		# reason, ssh-copy-id is not available on Macs...
		local sshKey=$($CAT $SSH_KEY_NAME)
		$SSH $SOURCE "echo $sshKey >> ~/.ssh/authorized_keys"
	fi

	# TODO: make this a var too.
	# cp config, known_hosts, authorized keys 
	$SCP ${SOURCE}:~/.ssh/\{config,authorized_keys,known_hosts\} $BACKUP_SETUP_DIR/
	test -d $sshBackupDir || $MKDIR $sshBackupDir
	test -e $HOME/.ssh/config && $MV $HOME/.ssh/config $sshBackupDir

	local sshFiles="$($LS $HOME/.ssh/{authorized_keys,known_hosts} 2> /dev/null)"
	test -n "$sshFiles" && $CP $sshFiles $sshBackupDir
	$MV ${BACKUP_SETUP_DIR}/config $HOME/.ssh
	$CAT ${BACKUP_SETUP_DIR}/authorized_keys >> $HOME/.ssh/authorized_keys
	$CAT ${BACKUP_SETUP_DIR}/known_hosts >> $HOME/.ssh/known_hosts

	return 0
}

function setup_shdotfiles() {
	local prefixed_dotfiles=""
	for f in $SHDOTFILES; do
		prefixed_dotfiles="${prefixed_dotfiles} ${DOTFILE_PREFIX}$f"
	done

	local dotfile_list=join , "$prefixed_dotfiles"
	$SCP $SOURCE:~/\{$dotfile_list\} ${BACKUP_SETUP_DIR}/

	for f in $dotfile_list; do
		test -e $HOME/$f && $MV $HOME/$f ${BACKUP_DIR}
		$MV ${BACKUP_SETUP_DIR}/$f $HOME
	done

	return 0
}

function setup_gitconfig() {
	$SCP ${SOURCE}:~/.gitconfig ${BACKUP_SETUP_DIR}/
	test -f $HOME/.gitconfig && $MV $HOME/.gitconfig ${BACKUP_DIR}
	$MV ${BACKUP_SETUP_DIR}/.gitconfig $HOME
}

function setup_gitrepo_gitconfig() {
	clone_source_gitrepo
	symlink_gitrepo_file gitconfig
}

function clone_source_gitrepo() {
	if ! test -d "${SOURCE_GIT_CLONE_DIR}/.git"; then
		if test -e "$SOURCE_GIT_CLONE_DIR"; then
			error_out "SOURCE_GIT_CLONE_DIR '${SOURCE_GIT_CLONE_DIR}' exists, but is not a git repository; bailing..."
		fi
		$GIT clone $GIT_CLONE_ARGS $SOURCE $SOURCE_GIT_CLONE_DIR
       fi
}

function setup_gitrepo_shdotfiles() {
	clone_source_gitrepo

	for f in $SHDOTFILES; do
		symlink_gitrepo_file $f
	done
}

test -z "$SOURCE" && error_out "Environment source must be defined."
echo "Environment source: $SOURCE"

# This isn't a very good test to see if $SOURCE is a Git repo; it grabs
# github in the hostname _or_ .git in the path, i.e. mymachine:/myrepo.git
if [ -n "$(echo $SOURCE | $GREP -i github)" ] ||
   [ -n "$(echo $SOURCE | $GREP -i '\.git$')" ]; then
	runMode="gitrepo"
else
	runMode="sourcehomedir"
fi

$MKDIR $BACKUP_DIR || true
$MKDIR ${BACKUP_SETUP_DIR} || true

for step in ${SETUP_STEPS}; do
	if [ "$runMode" == "gitrepo" ]; then
		setup_gitrepo_${step}
		echo "setup_gitrepo_${step}: $?"
	elif [ "$runMode" == "sourcehomedir" ]; then
		setup_${step}
		echo "setup_${step}: $?"
	else
		assert "main(): UNREACHABLE"
	fi
done

